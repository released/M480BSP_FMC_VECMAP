; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.BOOT_PROCESS||, CODE, READONLY, ALIGN=2

                  BOOT_PROCESS PROC
;;;138    
;;;139    void BOOT_PROCESS(void)
000000  490c              LDR      r1,|L1.52|
;;;140    {
000002  b510              PUSH     {r4,lr}
;;;141        if (addr_vector_map == 0x00)
000004  688a              LDR      r2,[r1,#8]  ; addr_vector_map
;;;142        {
;;;143            printf("under BANK1 : 0x00000 , reboot to VECT : 0x40000\r\n");
;;;144            FMC_SetVectorPageAddr(0x40000);
000006  f44f2480          MOV      r4,#0x40000
00000a  b162              CBZ      r2,|L1.38|
;;;145            SYS_ResetCPU();
;;;146    
;;;147        }
;;;148        else if (addr_vector_map == 0x40000)
00000c  6888              LDR      r0,[r1,#8]  ; addr_vector_map
00000e  42a0              CMP      r0,r4
000010  d10e              BNE      |L1.48|
;;;149        {
;;;150            printf("under BANK2 : 0x40000 , reboot to VECT : 0x00000\r\n");
000012  a009              ADR      r0,|L1.56|
000014  f7fffffe          BL       __2printf
;;;151            FMC_SetVectorPageAddr(0x0000);
000018  2000              MOVS     r0,#0
                  |L1.26|
00001a  f7fffffe          BL       FMC_SetVectorPageAddr
;;;152            SYS_ResetCPU();
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      SYS_ResetCPU
                  |L1.38|
000026  a011              ADR      r0,|L1.108|
000028  f7fffffe          BL       __2printf
00002c  4620              MOV      r0,r4                 ;144
00002e  e7f4              B        |L1.26|
                  |L1.48|
;;;153    
;;;154        }
;;;155    }
000030  bd10              POP      {r4,pc}
;;;156    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      ||.data||
                  |L1.56|
000038  756e6465          DCB      "under BANK2 : 0x40000 , reboot to VECT : 0x00000\r\n",0
00003c  72204241
000040  4e4b3220
000044  3a203078
000048  34303030
00004c  30202c20
000050  7265626f
000054  6f742074
000058  6f205645
00005c  4354203a
000060  20307830
000064  30303030
000068  0d0a00  
00006b  00                DCB      0
                  |L1.108|
00006c  756e6465          DCB      "under BANK1 : 0x00000 , reboot to VECT : 0x40000\r\n",0
000070  72204241
000074  4e4b3120
000078  3a203078
00007c  30303030
000080  30202c20
000084  7265626f
000088  6f742074
00008c  6f205645
000090  4354203a
000094  20307834
000098  30303030
00009c  0d0a00  
00009f  00                DCB      0

                          AREA ||i.FMC_SetVectorPageAddr||, CODE, READONLY, ALIGN=2

                  FMC_SetVectorPageAddr PROC
;;;303     */
;;;304    __STATIC_INLINE int32_t FMC_SetVectorPageAddr(uint32_t u32PageAddr)
000000  490c              LDR      r1,|L2.52|
;;;305    {
000002  b510              PUSH     {r4,lr}
;;;306        uint32_t  tout = FMC_TIMEOUT_WRITE;
000004  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000006  220a              MOVS     r2,#0xa
000008  fbb1f1f2          UDIV     r1,r1,r2
;;;307    
;;;308        g_FMC_i32ErrCode = 0;
00000c  4b0a              LDR      r3,|L2.56|
00000e  2200              MOVS     r2,#0
000010  0049              LSLS     r1,r1,#1              ;306
;;;309        FMC->ISPCMD = FMC_ISPCMD_VECMAP;  /* Set ISP Command Code */
000012  601a              STR      r2,[r3,#0]  ; g_FMC_i32ErrCode
000014  4a09              LDR      r2,|L2.60|
000016  242e              MOVS     r4,#0x2e
000018  60d4              STR      r4,[r2,#0xc]
;;;310        FMC->ISPADDR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
00001a  6050              STR      r0,[r2,#4]
;;;311        FMC->ISPTRG = 0x1u;               /* Trigger to start ISP procedure */
00001c  2001              MOVS     r0,#1
00001e  6110              STR      r0,[r2,#0x10]
000020  e002              B        |L2.40|
                  |L2.34|
;;;312    #if ISBEN
;;;313        __ISB();
;;;314    #endif                                /* To make sure ISP/CPU be Synchronized */
;;;315        while (tout-- > 0)
;;;316        {
;;;317            if (!FMC->ISPTRG)             /* Waiting for ISP Done */
000022  6910              LDR      r0,[r2,#0x10]
000024  2800              CMP      r0,#0
000026  d004              BEQ      |L2.50|
                  |L2.40|
000028  1e49              SUBS     r1,r1,#1
00002a  d2fa              BCS      |L2.34|
;;;318                return 0;
;;;319        }
;;;320        g_FMC_i32ErrCode = -1;
00002c  f04f30ff          MOV      r0,#0xffffffff
000030  6018              STR      r0,[r3,#0]  ; g_FMC_i32ErrCode
                  |L2.50|
;;;321        return -1;
;;;322    }
000032  bd10              POP      {r4,pc}
;;;323    
                          ENDP

                  |L2.52|
                          DCD      SystemCoreClock
                  |L2.56|
                          DCD      g_FMC_i32ErrCode
                  |L2.60|
                          DCD      0x4000c000

                          AREA ||i.GET_VECMAP||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  GET_VECMAP PROC
;;;156    
;;;157    void GET_VECMAP(void)
000000  b510              PUSH     {r4,lr}
;;;158    {
;;;159        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;160        FMC_Open();
000006  f7fffffe          BL       FMC_Open
00000a  4806              LDR      r0,|L3.36|
00000c  6c01              LDR      r1,[r0,#0x40]
00000e  4806              LDR      r0,|L3.40|
000010  4001              ANDS     r1,r1,r0
;;;161    
;;;162        addr_vector_map = FMC_GetVECMAP();
000012  4806              LDR      r0,|L3.44|
000014  6081              STR      r1,[r0,#8]  ; addr_vector_map
;;;163        printf("%s:0x%8X\r\n" , __FUNCTION__ ,addr_vector_map);
000016  6882              LDR      r2,[r0,#8]  ; addr_vector_map
000018  e8bd4010          POP      {r4,lr}
00001c  4904              LDR      r1,|L3.48|
00001e  a005              ADR      r0,|L3.52|
000020  f7ffbffe          B.W      __2printf
;;;164    
;;;165    }
;;;166    
                          ENDP

                  |L3.36|
                          DCD      0x4000c000
                  |L3.40|
                          DCD      0x00fffe00
                  |L3.44|
                          DCD      ||.data||
                  |L3.48|
                          DCD      ||.constdata||+0x5
                  |L3.52|
000034  25733a30          DCB      "%s:0x%8X\r\n",0
000038  78253858
00003c  0d0a00  
00003f  00                DCB      0

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;428    
;;;429    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;430    {
;;;431    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH0MFP_Msk)) | (SYS_GPH_MFPL_PH0MFP_GPIO);
000002  f04f4080          MOV      r0,#0x40000000
000006  6e81              LDR      r1,[r0,#0x68]
000008  f021010f          BIC      r1,r1,#0xf
00000c  6681              STR      r1,[r0,#0x68]
;;;432    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH1MFP_Msk)) | (SYS_GPH_MFPL_PH1MFP_GPIO);
00000e  6e81              LDR      r1,[r0,#0x68]
000010  f02101f0          BIC      r1,r1,#0xf0
000014  6681              STR      r1,[r0,#0x68]
;;;433    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH2MFP_Msk)) | (SYS_GPH_MFPL_PH2MFP_GPIO);
000016  6e81              LDR      r1,[r0,#0x68]
000018  f4216170          BIC      r1,r1,#0xf00
00001c  6681              STR      r1,[r0,#0x68]
;;;434    
;;;435    	//EVM LED
;;;436    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
00001e  4c09              LDR      r4,|L4.68|
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetMode
;;;437    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00002a  2201              MOVS     r2,#1
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetMode
;;;438    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000034  4620              MOV      r0,r4
000036  2201              MOVS     r2,#1
000038  e8bd4010          POP      {r4,lr}
00003c  2104              MOVS     r1,#4
00003e  f7ffbffe          B.W      GPIO_SetMode
;;;439    	
;;;440    }
;;;441    
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;441    
;;;442    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
;;;444        /* Unlock protected registers */
;;;445        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;446    
;;;447        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;448    //    PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
;;;449        
;;;450        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;451        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;452    
;;;453    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;454    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;455    
;;;456    //    CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
;;;457    //    CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
;;;458    
;;;459    //    CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk);
;;;460    //    CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk);
;;;461    
;;;462        /* Set core clock as PLL_CLOCK from PLL */
;;;463        CLK_SetCoreClock(FREQ_192MHZ);
000012  4814              LDR      r0,|L6.100|
000014  f7fffffe          BL       CLK_SetCoreClock
;;;464        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;465        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV1 | CLK_PCLKDIV_APB1DIV_DIV1);
000018  f04f4480          MOV      r4,#0x40000000
00001c  2500              MOVS     r5,#0
00001e  f8c45234          STR      r5,[r4,#0x234]
;;;466    
;;;467        /* Enable UART clock */
;;;468        CLK_EnableModuleClock(UART0_MODULE);
000022  4e11              LDR      r6,|L6.104|
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       CLK_EnableModuleClock
;;;469        /* Select UART clock source from HXT */
;;;470        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
00002a  2200              MOVS     r2,#0
00002c  f04f7140          MOV      r1,#0x3000000
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       CLK_SetModuleClock
;;;471    
;;;472        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;473        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000036  6be0              LDR      r0,[r4,#0x3c]
000038  f420007f          BIC      r0,r0,#0xff0000
00003c  63e0              STR      r0,[r4,#0x3c]
;;;474        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00003e  6be0              LDR      r0,[r4,#0x3c]
000040  f44000cc          ORR      r0,r0,#0x660000
000044  63e0              STR      r0,[r4,#0x3c]
;;;475    
;;;476        CLK_EnableModuleClock(TMR1_MODULE);
000046  4e09              LDR      r6,|L6.108|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;477        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00004e  2200              MOVS     r2,#0
000050  f44f41e0          MOV      r1,#0x7000
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       CLK_SetModuleClock
;;;478    	
;;;479        /* Update System Core Clock */
;;;480        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;481        SystemCoreClockUpdate();
00005a  f7fffffe          BL       SystemCoreClockUpdate
00005e  f8c45100          STR      r5,[r4,#0x100]
;;;482    
;;;483        /* Lock protected registers */
;;;484        SYS_LockReg();
;;;485    }
000062  bd70              POP      {r4-r6,pc}
;;;486    
                          ENDP

                  |L6.100|
                          DCD      0x0b71b000
                  |L6.104|
                          DCD      0x57803d10
                  |L6.108|
                          DCD      0x5ec00003

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L7.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1590
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1591
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L7.10|
;;;1595   }
00001e  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;45     
;;;46     void SysTick_Handler(void)
000000  b500              PUSH     {lr}
;;;47     {
;;;48     
;;;49         systick_counter();
000002  f7fffffe          BL       systick_counter
000006  4903              LDR      r1,|L8.20|
000008  6808              LDR      r0,[r1,#0]  ; counter_systick
00000a  1c40              ADDS     r0,r0,#1
;;;50     
;;;51         if (get_systick() >= 0xFFFFFFFF)
00000c  d100              BNE      |L8.16|
00000e  6008              STR      r0,[r1,#0]  ; counter_systick
                  |L8.16|
;;;52         {
;;;53             set_systick(0);      
;;;54         }
;;;55     
;;;56         // if ((get_systick() % 1000) == 0)
;;;57         // {
;;;58            
;;;59         // }
;;;60     
;;;61         #if defined (ENABLE_TICK_EVENT)
;;;62         TickCheckTickEvent();
;;;63         #endif    
;;;64     }
000010  bd00              POP      {pc}
;;;65     
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      ||.data||

                          AREA ||i.SysTick_delay||, CODE, READONLY, ALIGN=2

                  SysTick_delay PROC
;;;65     
;;;66     void SysTick_delay(unsigned int delay)
000000  4903              LDR      r1,|L9.16|
000002  680a              LDR      r2,[r1,#0]  ; counter_systick
                  |L9.4|
000004  680b              LDR      r3,[r1,#0]  ; counter_systick
;;;67     {  
;;;68         
;;;69         unsigned int tickstart = get_systick(); 
;;;70         unsigned int wait = delay; 
;;;71     
;;;72         while((get_systick() - tickstart) < wait) 
000006  1a9b              SUBS     r3,r3,r2
000008  4283              CMP      r3,r0
00000a  d3fb              BCC      |L9.4|
;;;73         { 
;;;74         } 
;;;75     
;;;76     }
00000c  4770              BX       lr
;;;77     
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ||.data||

                          AREA ||i.SysTick_enable||, CODE, READONLY, ALIGN=2

                  SysTick_enable PROC
;;;77     
;;;78     void SysTick_enable(unsigned int ticks_per_second)
000000  4a0d              LDR      r2,|L10.56|
;;;79     {
000002  b510              PUSH     {r4,lr}
;;;80         set_systick(0);
000004  2100              MOVS     r1,#0
000006  6011              STR      r1,[r2,#0]  ; counter_systick
;;;81         if (SysTick_Config(SystemCoreClock / ticks_per_second))
000008  490c              LDR      r1,|L10.60|
00000a  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  1e40              SUBS     r0,r0,#1
000012  f1b07f80          CMP      r0,#0x1000000
000016  d303              BCC      |L10.32|
;;;82         {
;;;83             /* Setup SysTick Timer for 1 second interrupts  */
;;;84             printf("Set system tick error!!\n");
000018  a009              ADR      r0,|L10.64|
00001a  f7fffffe          BL       __2printf
                  |L10.30|
;;;85             while (1);
00001e  e7fe              B        |L10.30|
                  |L10.32|
000020  f04f21e0          MOV      r1,#0xe000e000
000024  6148              STR      r0,[r1,#0x14]
000026  4a0d              LDR      r2,|L10.92|
000028  20f0              MOVS     r0,#0xf0
00002a  f8820d14          STRB     r0,[r2,#0xd14]
00002e  2000              MOVS     r0,#0
000030  6188              STR      r0,[r1,#0x18]
000032  2007              MOVS     r0,#7
000034  6108              STR      r0,[r1,#0x10]
;;;86         }
;;;87     
;;;88         #if defined (ENABLE_TICK_EVENT)
;;;89         TickInitTickEvent();
;;;90         #endif
;;;91     }
000036  bd10              POP      {r4,pc}
;;;92     
                          ENDP

                  |L10.56|
                          DCD      ||.data||
                  |L10.60|
                          DCD      SystemCoreClock
                  |L10.64|
000040  53657420          DCB      "Set system tick error!!\n",0
000044  73797374
000048  656d2074
00004c  69636b20
000050  6572726f
000054  7221210a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L10.92|
                          DCD      0xe000e00f

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;304    
;;;305    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L11.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;308        TIMER_EnableInt(TIMER1);
;;;309        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;310        TIMER_Start(TIMER1);
;;;311    }
000028  bd10              POP      {r4,pc}
;;;312    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;284    
;;;285    void TMR1_IRQHandler(void)
000000  480d              LDR      r0,|L12.56|
;;;286    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d013              BEQ      |L12.54|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;287    	
;;;288        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;289        {
;;;290            TIMER_ClearIntFlag(TIMER1);
;;;291    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a09              LDR      r2,|L12.60|
000018  6850              LDR      r0,[r2,#4]  ; counter_tick
;;;292    
;;;293    		if ((get_tick() % 1000) == 0)
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fbb0f3f1          UDIV     r3,r0,r1
000022  fb010013          MLS      r0,r1,r3,r0
000026  b928              CBNZ     r0,|L12.52|
;;;294    		{
;;;295                FLAG_PROJ_TIMER_PERIOD_1000MS = 1;//set_flag(flag_timer_period_1000ms ,ENABLE);
000028  f1020010          ADD      r0,r2,#0x10
00002c  6801              LDR      r1,[r0,#0]  ; flag_PROJ_CTL
00002e  f0410101          ORR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]  ; flag_PROJ_CTL
                  |L12.52|
000034  6850              LDR      r0,[r2,#4]  ; counter_tick
                  |L12.54|
;;;296    		}
;;;297    
;;;298    		if ((get_tick() % 50) == 0)
;;;299    		{
;;;300    
;;;301    		}	
;;;302        }
;;;303    }
000036  bd00              POP      {pc}
;;;304    
                          ENDP

                  |L12.56|
                          DCD      0x40050100
                  |L12.60|
                          DCD      ||.data||

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;368    
;;;369    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;370    {
;;;371        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L13.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L13.18|
00000c  e004              B        |L13.24|
                  |L13.14|
;;;372        {
;;;373            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;374            {
;;;375    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L13.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;373
000014  0449              LSLS     r1,r1,#17             ;373
000016  d5fa              BPL      |L13.14|
                  |L13.24|
;;;376            }
;;;377        }
;;;378    
;;;379        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L13.46|
;;;380        {
;;;381            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L13.46|
;;;382        }	
;;;383    }
00002e  bd10              POP      {r4,pc}
;;;384    
                          ENDP

                  |L13.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;384    
;;;385    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;386    {
;;;387        SYS_ResetModule(UART0_RST);
000002  4824              LDR      r0,|L14.148|
000004  f7fffffe          BL       SYS_ResetModule
;;;388    
;;;389        /* Configure UART0 and set UART0 baud rate */
;;;390        UART_Open(UART0, 115200);
000008  4c23              LDR      r4,|L14.152|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;391    
;;;392    	/* Set UART receive time-out */
;;;393    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;394    
;;;395    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;396    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;397    
;;;398    	/* Enable UART Interrupt - */
;;;399    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;400    	
;;;401    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;402    
;;;403    	#if (_debug_log_UART_ == 1)	//debug
;;;404    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a016              ADR      r0,|L14.156|
000044  f7fffffe          BL       __2printf
;;;405    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());
000048  f7fffffe          BL       CLK_GetHCLKFreq
00004c  4601              MOV      r1,r0
00004e  a01a              ADR      r0,|L14.184|
000050  f7fffffe          BL       __2printf
;;;406    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000054  f7fffffe          BL       CLK_GetHXTFreq
000058  4601              MOV      r1,r0
00005a  a01d              ADR      r0,|L14.208|
00005c  f7fffffe          BL       __2printf
;;;407    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000060  f7fffffe          BL       CLK_GetLXTFreq
000064  4601              MOV      r1,r0
000066  a020              ADR      r0,|L14.232|
000068  f7fffffe          BL       __2printf
;;;408    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00006c  f7fffffe          BL       CLK_GetPCLK0Freq
000070  4601              MOV      r1,r0
000072  a023              ADR      r0,|L14.256|
000074  f7fffffe          BL       __2printf
;;;409    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000078  f7fffffe          BL       CLK_GetPCLK1Freq
00007c  4601              MOV      r1,r0
00007e  a027              ADR      r0,|L14.284|
000080  f7fffffe          BL       __2printf
;;;410    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());    	
000084  f7fffffe          BL       CLK_GetHCLKFreq
000088  4601              MOV      r1,r0
00008a  e8bd4010          POP      {r4,lr}
00008e  a00a              ADR      r0,|L14.184|
000090  f7ffbffe          B.W      __2printf
;;;411    
;;;412    //    printf("Product ID 0x%8X\n", SYS->PDID);
;;;413    	
;;;414    	#endif	
;;;415    
;;;416        #if 0
;;;417        printf("FLAG_PROJ_TIMER_PERIOD_1000MS : 0x%2X\r\n",FLAG_PROJ_TIMER_PERIOD_1000MS);
;;;418        printf("FLAG_PROJ_REVERSE1 : 0x%2X\r\n",FLAG_PROJ_REVERSE1);
;;;419        printf("FLAG_PROJ_REVERSE2 : 0x%2X\r\n",FLAG_PROJ_REVERSE2);
;;;420        printf("FLAG_PROJ_REVERSE3 : 0x%2X\r\n",FLAG_PROJ_REVERSE3);
;;;421        printf("FLAG_PROJ_REVERSE4 : 0x%2X\r\n",FLAG_PROJ_REVERSE4);
;;;422        printf("FLAG_PROJ_REVERSE5 : 0x%2X\r\n",FLAG_PROJ_REVERSE5);
;;;423        printf("FLAG_PROJ_REVERSE6 : 0x%2X\r\n",FLAG_PROJ_REVERSE6);
;;;424        printf("FLAG_PROJ_REVERSE7 : 0x%2X\r\n",FLAG_PROJ_REVERSE7);
;;;425        #endif
;;;426    
;;;427    }
;;;428    
                          ENDP

                  |L14.148|
                          DCD      0x04000010
                  |L14.152|
                          DCD      0x40070000
                  |L14.156|
00009c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000a0  4b5f4765
0000a4  74435055
0000a8  46726571
0000ac  203a2025
0000b0  38640d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L14.184|
0000b8  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000bc  47657448
0000c0  434c4b46
0000c4  72657120
0000c8  3a202538
0000cc  640d0a00
                  |L14.208|
0000d0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000d4  47657448
0000d8  58544672
0000dc  6571203a
0000e0  20253864
0000e4  0d0a00  
0000e7  00                DCB      0
                  |L14.232|
0000e8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000ec  4765744c
0000f0  58544672
0000f4  6571203a
0000f8  20253864
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L14.256|
000100  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
000104  47657450
000108  434c4b30
00010c  46726571
000110  203a2025
000114  38640d0a
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L14.284|
00011c  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000120  47657450
000124  434c4b31
000128  46726571
00012c  203a2025
000130  38640d0a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  UARTx_Process PROC
;;;337    
;;;338    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;339    {
;;;340    	uint8_t res = 0;
;;;341    	res = UART_READ(UART0);
000002  4813              LDR      r0,|L15.80|
000004  6800              LDR      r0,[r0,#0]
000006  b2c4              UXTB     r4,r0
;;;342    
;;;343    	if (res > 0x7F)
000008  2c7f              CMP      r4,#0x7f
00000a  d904              BLS      |L15.22|
;;;344    	{
;;;345    		printf("invalid command\r\n");
00000c  e8bd4010          POP      {r4,lr}
000010  a010              ADR      r0,|L15.84|
000012  f7ffbffe          B.W      __2printf
                  |L15.22|
;;;346    	}
;;;347    	else
;;;348    	{
;;;349    		printf("press : %c\r\n" , res);
000016  4621              MOV      r1,r4
000018  a013              ADR      r0,|L15.104|
00001a  f7fffffe          BL       __2printf
;;;350    		switch(res)
00001e  2c5a              CMP      r4,#0x5a
000020  d009              BEQ      |L15.54|
000022  dc04              BGT      |L15.46|
000024  2c31              CMP      r4,#0x31
000026  d00c              BEQ      |L15.66|
000028  2c58              CMP      r4,#0x58
00002a  d10f              BNE      |L15.76|
00002c  e003              B        |L15.54|
                  |L15.46|
00002e  2c78              CMP      r4,#0x78
000030  d001              BEQ      |L15.54|
000032  2c7a              CMP      r4,#0x7a
000034  d10a              BNE      |L15.76|
                  |L15.54|
;;;351    		{
;;;352    			case '1':
;;;353                    FLAG_PROJ_BOOT_PROCESS = 1;
;;;354    				break;
;;;355    
;;;356    			case 'X':
;;;357    			case 'x':
;;;358    			case 'Z':
;;;359    			case 'z':
;;;360                    SYS_UnlockReg();
000036  f7fffffe          BL       SYS_UnlockReg
;;;361    				// NVIC_SystemReset();	// Reset I/O and peripherals , only check BS(FMC_ISPCTL[1])
;;;362                    // SYS_ResetCPU();     // Not reset I/O and peripherals
;;;363                    SYS_ResetChip();    // Reset I/O and peripherals ,  BS(FMC_ISPCTL[1]) reload from CONFIG setting (CBS)	
00003a  e8bd4010          POP      {r4,lr}
00003e  f7ffbffe          B.W      SYS_ResetChip
                  |L15.66|
000042  480d              LDR      r0,|L15.120|
000044  6801              LDR      r1,[r0,#0]            ;353  ; flag_PROJ_CTL
000046  f0410102          ORR      r1,r1,#2              ;353
00004a  6001              STR      r1,[r0,#0]            ;353  ; flag_PROJ_CTL
                  |L15.76|
;;;364    				break;
;;;365    		}
;;;366    	}
;;;367    }
00004c  bd10              POP      {r4,pc}
;;;368    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      0x40070000
                  |L15.84|
000054  696e7661          DCB      "invalid command\r\n",0
000058  6c696420
00005c  636f6d6d
000060  616e640d
000064  0a00    
000066  00                DCB      0
000067  00                DCB      0
                  |L15.104|
000068  70726573          DCB      "press : %c\r\n",0
00006c  73203a20
000070  25630d0a
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L15.120|
                          DCD      ||.data||+0x10

                          AREA ||i.check_reset_source||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  check_reset_source PROC
;;;169    //
;;;170    uint8_t check_reset_source(void)
000000  b570              PUSH     {r4-r6,lr}
;;;171    {
;;;172        uint32_t src = SYS_GetResetSrc();
000002  f7fffffe          BL       SYS_GetResetSrc
;;;173    
;;;174        if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)    // M48xGCAE
000006  f04f4580          MOV      r5,#0x40000000
00000a  4604              MOV      r4,r0                 ;172
00000c  f8d501f4          LDR      r0,[r5,#0x1f4]
000010  b2c0              UXTB     r0,r0
000012  2801              CMP      r0,#1
000014  d03f              BEQ      |L16.150|
;;;175        {
;;;176    		printf("PN : M48xGCAE\r\n");
;;;177        }
;;;178        else    // M48xIDAE
;;;179        {
;;;180    		printf("PN : M48xIDAE\r\n");
000016  a03c              ADR      r0,|L16.264|
                  |L16.24|
000018  f7fffffe          BL       __2printf
;;;181        }
;;;182    
;;;183        SYS->RSTSTS |= 0x1FF;
00001c  6868              LDR      r0,[r5,#4]
00001e  f24011ff          MOV      r1,#0x1ff
000022  4308              ORRS     r0,r0,r1
000024  6068              STR      r0,[r5,#4]
;;;184        printf("Reset Source <0x%08X>\r\n", src);
000026  4621              MOV      r1,r4
000028  a03b              ADR      r0,|L16.280|
00002a  f7fffffe          BL       __2printf
;;;185    
;;;186        #if 1   //DEBUG , list reset source
;;;187        if (src & BIT0)
00002e  07e0              LSLS     r0,r4,#31
000030  d002              BEQ      |L16.56|
;;;188        {
;;;189            printf("0)POR Reset Flag\r\n");       
000032  a03f              ADR      r0,|L16.304|
000034  f7fffffe          BL       __2printf
                  |L16.56|
;;;190        }
;;;191        if (src & BIT1)
000038  07a0              LSLS     r0,r4,#30
00003a  d502              BPL      |L16.66|
;;;192        {
;;;193            printf("1)NRESET Pin Reset Flag\r\n");       
00003c  a041              ADR      r0,|L16.324|
00003e  f7fffffe          BL       __2printf
                  |L16.66|
;;;194        }
;;;195        if (src & BIT2)
000042  0760              LSLS     r0,r4,#29
000044  d502              BPL      |L16.76|
;;;196        {
;;;197            printf("2)WDT Reset Flag\r\n");       
000046  a046              ADR      r0,|L16.352|
000048  f7fffffe          BL       __2printf
                  |L16.76|
;;;198        }
;;;199        if (src & BIT3)
00004c  0720              LSLS     r0,r4,#28
00004e  d502              BPL      |L16.86|
;;;200        {
;;;201            printf("3)LVR Reset Flag\r\n");       
000050  a048              ADR      r0,|L16.372|
000052  f7fffffe          BL       __2printf
                  |L16.86|
;;;202        }
;;;203        if (src & BIT4)
000056  06e0              LSLS     r0,r4,#27
000058  d502              BPL      |L16.96|
;;;204        {
;;;205            printf("4)BOD Reset Flag\r\n");       
00005a  a04b              ADR      r0,|L16.392|
00005c  f7fffffe          BL       __2printf
                  |L16.96|
;;;206        }
;;;207        if (src & BIT5)
000060  06a0              LSLS     r0,r4,#26
000062  d502              BPL      |L16.106|
;;;208        {
;;;209            printf("5)System Reset Flag \r\n");       
000064  a04d              ADR      r0,|L16.412|
000066  f7fffffe          BL       __2printf
                  |L16.106|
;;;210        }
;;;211        if (src & BIT6)
00006a  0660              LSLS     r0,r4,#25
00006c  d502              BPL      |L16.116|
;;;212        {
;;;213            printf("6)HRESET Reset Flag \r\n");       
00006e  a051              ADR      r0,|L16.436|
000070  f7fffffe          BL       __2printf
                  |L16.116|
;;;214        }
;;;215        if (src & BIT7)
000074  0620              LSLS     r0,r4,#24
000076  d502              BPL      |L16.126|
;;;216        {
;;;217            printf("7)CPU Reset Flag\r\n");       
000078  a054              ADR      r0,|L16.460|
00007a  f7fffffe          BL       __2printf
                  |L16.126|
;;;218        }
;;;219        if (src & BIT8)
00007e  05e0              LSLS     r0,r4,#23
000080  d502              BPL      |L16.136|
;;;220        {
;;;221            printf("8)CPU Lockup Reset Flag\r\n");       
000082  a057              ADR      r0,|L16.480|
000084  f7fffffe          BL       __2printf
                  |L16.136|
;;;222        }
;;;223        #endif
;;;224        
;;;225        if (src & SYS_RSTSTS_PORF_Msk) {
000088  07e0              LSLS     r0,r4,#31
00008a  d006              BEQ      |L16.154|
;;;226            SYS_ClearResetSrc(SYS_RSTSTS_PORF_Msk);
00008c  2001              MOVS     r0,#1
00008e  f7fffffe          BL       SYS_ClearResetSrc
;;;227            
;;;228            printf("power on from POR\r\n");
000092  a05a              ADR      r0,|L16.508|
;;;229            return FALSE;
000094  e032              B        |L16.252|
                  |L16.150|
000096  a05e              ADR      r0,|L16.528|
000098  e7be              B        |L16.24|
                  |L16.154|
;;;230        }    
;;;231        else if (src & SYS_RSTSTS_PINRF_Msk)
00009a  07a0              LSLS     r0,r4,#30
00009c  d504              BPL      |L16.168|
;;;232        {
;;;233            SYS_ClearResetSrc(SYS_RSTSTS_PINRF_Msk);
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       SYS_ClearResetSrc
;;;234            
;;;235            printf("power on from nRESET pin\r\n");
0000a4  a05e              ADR      r0,|L16.544|
;;;236            return FALSE;
0000a6  e029              B        |L16.252|
                  |L16.168|
;;;237        } 
;;;238        else if (src & SYS_RSTSTS_WDTRF_Msk)
0000a8  0760              LSLS     r0,r4,#29
0000aa  d504              BPL      |L16.182|
;;;239        {
;;;240            SYS_ClearResetSrc(SYS_RSTSTS_WDTRF_Msk);
0000ac  2004              MOVS     r0,#4
0000ae  f7fffffe          BL       SYS_ClearResetSrc
;;;241            
;;;242            printf("power on from WDT Reset\r\n");
0000b2  a062              ADR      r0,|L16.572|
;;;243            return FALSE;
0000b4  e022              B        |L16.252|
                  |L16.182|
;;;244        }    
;;;245        else if (src & SYS_RSTSTS_LVRF_Msk)
0000b6  0720              LSLS     r0,r4,#28
0000b8  d504              BPL      |L16.196|
;;;246        {
;;;247            SYS_ClearResetSrc(SYS_RSTSTS_LVRF_Msk);
0000ba  2008              MOVS     r0,#8
0000bc  f7fffffe          BL       SYS_ClearResetSrc
;;;248            
;;;249            printf("power on from LVR Reset\r\n");
0000c0  a065              ADR      r0,|L16.600|
;;;250            return FALSE;
0000c2  e01b              B        |L16.252|
                  |L16.196|
;;;251        }    
;;;252        else if (src & SYS_RSTSTS_BODRF_Msk)
0000c4  06e0              LSLS     r0,r4,#27
0000c6  d504              BPL      |L16.210|
;;;253        {
;;;254            SYS_ClearResetSrc(SYS_RSTSTS_BODRF_Msk);
0000c8  2010              MOVS     r0,#0x10
0000ca  f7fffffe          BL       SYS_ClearResetSrc
;;;255            
;;;256            printf("power on from BOD Reset\r\n");
0000ce  a069              ADR      r0,|L16.628|
;;;257            return FALSE;
0000d0  e014              B        |L16.252|
                  |L16.210|
;;;258        }    
;;;259        else if (src & SYS_RSTSTS_SYSRF_Msk)
0000d2  06a0              LSLS     r0,r4,#26
0000d4  d504              BPL      |L16.224|
;;;260        {
;;;261            SYS_ClearResetSrc(SYS_RSTSTS_SYSRF_Msk);
0000d6  2020              MOVS     r0,#0x20
0000d8  f7fffffe          BL       SYS_ClearResetSrc
;;;262            
;;;263            printf("power on from System Reset\r\n");
0000dc  a06c              ADR      r0,|L16.656|
;;;264            return FALSE;
0000de  e00d              B        |L16.252|
                  |L16.224|
;;;265        } 
;;;266        else if (src & SYS_RSTSTS_CPURF_Msk)
0000e0  0620              LSLS     r0,r4,#24
0000e2  d504              BPL      |L16.238|
;;;267        {
;;;268            SYS_ClearResetSrc(SYS_RSTSTS_CPURF_Msk);
0000e4  2080              MOVS     r0,#0x80
0000e6  f7fffffe          BL       SYS_ClearResetSrc
;;;269    
;;;270            printf("power on from CPU reset\r\n");
0000ea  a071              ADR      r0,|L16.688|
;;;271            return FALSE;         
0000ec  e006              B        |L16.252|
                  |L16.238|
;;;272        }    
;;;273        else if (src & SYS_RSTSTS_CPULKRF_Msk)
0000ee  05e0              LSLS     r0,r4,#23
0000f0  d508              BPL      |L16.260|
;;;274        {
;;;275            SYS_ClearResetSrc(SYS_RSTSTS_CPULKRF_Msk);
0000f2  f44f7080          MOV      r0,#0x100
0000f6  f7fffffe          BL       SYS_ClearResetSrc
;;;276            
;;;277            printf("power on from CPU Lockup Reset\r\n");
0000fa  a074              ADR      r0,|L16.716|
                  |L16.252|
;;;278            return FALSE;
;;;279        }   
;;;280        
;;;281        printf("power on from unhandle reset source\r\n");
0000fc  f7fffffe          BL       __2printf
;;;282        return FALSE;
000100  2000              MOVS     r0,#0
;;;283    }
000102  bd70              POP      {r4-r6,pc}
                  |L16.260|
000104  a07a              ADR      r0,|L16.752|
000106  e7f9              B        |L16.252|
;;;284    
                          ENDP

                  |L16.264|
000108  504e203a          DCB      "PN : M48xIDAE\r\n",0
00010c  204d3438
000110  78494441
000114  450d0a00
                  |L16.280|
000118  52657365          DCB      "Reset Source <0x%08X>\r\n",0
00011c  7420536f
000120  75726365
000124  203c3078
000128  25303858
00012c  3e0d0a00
                  |L16.304|
000130  3029504f          DCB      "0)POR Reset Flag\r\n",0
000134  52205265
000138  73657420
00013c  466c6167
000140  0d0a00  
000143  00                DCB      0
                  |L16.324|
000144  31294e52          DCB      "1)NRESET Pin Reset Flag\r\n",0
000148  45534554
00014c  2050696e
000150  20526573
000154  65742046
000158  6c61670d
00015c  0a00    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L16.352|
000160  32295744          DCB      "2)WDT Reset Flag\r\n",0
000164  54205265
000168  73657420
00016c  466c6167
000170  0d0a00  
000173  00                DCB      0
                  |L16.372|
000174  33294c56          DCB      "3)LVR Reset Flag\r\n",0
000178  52205265
00017c  73657420
000180  466c6167
000184  0d0a00  
000187  00                DCB      0
                  |L16.392|
000188  3429424f          DCB      "4)BOD Reset Flag\r\n",0
00018c  44205265
000190  73657420
000194  466c6167
000198  0d0a00  
00019b  00                DCB      0
                  |L16.412|
00019c  35295379          DCB      "5)System Reset Flag \r\n",0
0001a0  7374656d
0001a4  20526573
0001a8  65742046
0001ac  6c616720
0001b0  0d0a00  
0001b3  00                DCB      0
                  |L16.436|
0001b4  36294852          DCB      "6)HRESET Reset Flag \r\n",0
0001b8  45534554
0001bc  20526573
0001c0  65742046
0001c4  6c616720
0001c8  0d0a00  
0001cb  00                DCB      0
                  |L16.460|
0001cc  37294350          DCB      "7)CPU Reset Flag\r\n",0
0001d0  55205265
0001d4  73657420
0001d8  466c6167
0001dc  0d0a00  
0001df  00                DCB      0
                  |L16.480|
0001e0  38294350          DCB      "8)CPU Lockup Reset Flag\r\n",0
0001e4  55204c6f
0001e8  636b7570
0001ec  20526573
0001f0  65742046
0001f4  6c61670d
0001f8  0a00    
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L16.508|
0001fc  706f7765          DCB      "power on from POR\r\n",0
000200  72206f6e
000204  2066726f
000208  6d20504f
00020c  520d0a00
                  |L16.528|
000210  504e203a          DCB      "PN : M48xGCAE\r\n",0
000214  204d3438
000218  78474341
00021c  450d0a00
                  |L16.544|
000220  706f7765          DCB      "power on from nRESET pin\r\n",0
000224  72206f6e
000228  2066726f
00022c  6d206e52
000230  45534554
000234  2070696e
000238  0d0a00  
00023b  00                DCB      0
                  |L16.572|
00023c  706f7765          DCB      "power on from WDT Reset\r\n",0
000240  72206f6e
000244  2066726f
000248  6d205744
00024c  54205265
000250  7365740d
000254  0a00    
000256  00                DCB      0
000257  00                DCB      0
                  |L16.600|
000258  706f7765          DCB      "power on from LVR Reset\r\n",0
00025c  72206f6e
000260  2066726f
000264  6d204c56
000268  52205265
00026c  7365740d
000270  0a00    
000272  00                DCB      0
000273  00                DCB      0
                  |L16.628|
000274  706f7765          DCB      "power on from BOD Reset\r\n",0
000278  72206f6e
00027c  2066726f
000280  6d20424f
000284  44205265
000288  7365740d
00028c  0a00    
00028e  00                DCB      0
00028f  00                DCB      0
                  |L16.656|
000290  706f7765          DCB      "power on from System Reset\r\n",0
000294  72206f6e
000298  2066726f
00029c  6d205379
0002a0  7374656d
0002a4  20526573
0002a8  65740d0a
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L16.688|
0002b0  706f7765          DCB      "power on from CPU reset\r\n",0
0002b4  72206f6e
0002b8  2066726f
0002bc  6d204350
0002c0  55207265
0002c4  7365740d
0002c8  0a00    
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L16.716|
0002cc  706f7765          DCB      "power on from CPU Lockup Reset\r\n",0
0002d0  72206f6e
0002d4  2066726f
0002d8  6d204350
0002dc  55204c6f
0002e0  636b7570
0002e4  20526573
0002e8  65740d0a
0002ec  00      
0002ed  00                DCB      0
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L16.752|
0002f0  706f7765          DCB      "power on from unhandle reset source\r\n",0
0002f4  72206f6e
0002f8  2066726f
0002fc  6d20756e
000300  68616e64
000304  6c652072
000308  65736574
00030c  20736f75
000310  7263650d
000314  0a00    
000316  00                DCB      0
000317  00                DCB      0

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;111    
;;;112    void delay_ms(uint16_t ms)
000000  4b07              LDR      r3,|L17.32|
;;;113    {
000002  b510              PUSH     {r4,lr}
000004  6859              LDR      r1,[r3,#4]  ; counter_tick
;;;114    	#if 1
;;;115        uint32_t tickstart = get_tick();
;;;116        uint32_t wait = ms;
;;;117    	uint32_t tmp = 0;
;;;118    	
;;;119        while (1)
;;;120        {
;;;121    		if (get_tick() > tickstart)	// tickstart = 59000 , tick_counter = 60000
;;;122    		{
;;;123    			tmp = get_tick() - tickstart;
;;;124    		}
;;;125    		else // tickstart = 59000 , tick_counter = 2048
;;;126    		{
;;;127    			tmp = 60000 -  tickstart + get_tick();
000006  f64e2260          MOV      r2,#0xea60
00000a  1a54              SUBS     r4,r2,r1
                  |L17.12|
00000c  685a              LDR      r2,[r3,#4]  ; counter_tick
00000e  428a              CMP      r2,r1                 ;121
000010  685a              LDR      r2,[r3,#4]            ;121  ; counter_tick
000012  d901              BLS      |L17.24|
000014  1a52              SUBS     r2,r2,r1              ;123
000016  e000              B        |L17.26|
                  |L17.24|
000018  4422              ADD      r2,r2,r4
                  |L17.26|
;;;128    		}		
;;;129    		
;;;130    		if (tmp > wait)
00001a  4282              CMP      r2,r0
00001c  d9f6              BLS      |L17.12|
;;;131    			break;
;;;132        }
;;;133    	
;;;134    	#else
;;;135    	TIMER_Delay(TIMER0, 1000*ms);
;;;136    	#endif
;;;137    }
00001e  bd10              POP      {r4,pc}
;;;138    
                          ENDP

                  |L17.32|
                          DCD      ||.data||

                          AREA ||i.get_systick||, CODE, READONLY, ALIGN=2

                  get_systick PROC
;;;30     
;;;31     unsigned int get_systick(void)
000000  4801              LDR      r0,|L18.8|
;;;32     {
;;;33     	return (counter_systick);
000002  6800              LDR      r0,[r0,#0]  ; counter_systick
;;;34     }
000004  4770              BX       lr
;;;35     
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;92     
;;;93     uint32_t get_tick(void)
000000  4801              LDR      r0,|L19.8|
;;;94     {
;;;95     	return (counter_tick);
000002  6840              LDR      r0,[r0,#4]  ; counter_tick
;;;96     }
000004  4770              BX       lr
;;;97     
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      ||.data||

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  loop PROC
;;;312    
;;;313    void loop(void)
000000  b510              PUSH     {r4,lr}
000002  4911              LDR      r1,|L20.72|
000004  6808              LDR      r0,[r1,#0]  ; counter_systick
;;;314    {
;;;315    	static uint32_t LOG1 = 0;
;;;316    	// static uint32_t LOG2 = 0;
;;;317    
;;;318        if ((get_systick() % 1000) == 0)
;;;319        {
;;;320            // printf("%s(systick) : %4d\r\n",__FUNCTION__,LOG2++);    
;;;321        }
;;;322    
;;;323        if (FLAG_PROJ_TIMER_PERIOD_1000MS)//(is_flag_set(flag_timer_period_1000ms))
000006  f1010410          ADD      r4,r1,#0x10
00000a  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
00000c  07c2              LSLS     r2,r0,#31
00000e  d00f              BEQ      |L20.48|
;;;324        {
;;;325            FLAG_PROJ_TIMER_PERIOD_1000MS = 0;//set_flag(flag_timer_period_1000ms ,DISABLE);
000010  f0200001          BIC      r0,r0,#1
;;;326    
;;;327            printf("%s(timer) : %4d , vector map : 0x%8X\r\n",__FUNCTION__,LOG1++ , addr_vector_map);
000014  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000016  68ca              LDR      r2,[r1,#0xc]  ; LOG1
000018  1c50              ADDS     r0,r2,#1
00001a  60c8              STR      r0,[r1,#0xc]  ; LOG1
00001c  688b              LDR      r3,[r1,#8]  ; addr_vector_map
00001e  490b              LDR      r1,|L20.76|
000020  a00b              ADR      r0,|L20.80|
000022  f7fffffe          BL       __2printf
;;;328            PH0 ^= 1;             
000026  4814              LDR      r0,|L20.120|
000028  6801              LDR      r1,[r0,#0]
00002a  f0810101          EOR      r1,r1,#1
00002e  6001              STR      r1,[r0,#0]
                  |L20.48|
;;;329        }
;;;330    
;;;331        if (FLAG_PROJ_BOOT_PROCESS)
000030  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000032  0781              LSLS     r1,r0,#30
000034  d506              BPL      |L20.68|
;;;332        {
;;;333            FLAG_PROJ_BOOT_PROCESS = 0;
000036  f0200002          BIC      r0,r0,#2
;;;334            BOOT_PROCESS();        
00003a  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
00003c  e8bd4010          POP      {r4,lr}
000040  f7ffbffe          B.W      BOOT_PROCESS
                  |L20.68|
;;;335        }
;;;336    }
000044  bd10              POP      {r4,pc}
;;;337    
                          ENDP

000046  0000              DCW      0x0000
                  |L20.72|
                          DCD      ||.data||
                  |L20.76|
                          DCD      ||.constdata||
                  |L20.80|
000050  25732874          DCB      "%s(timer) : %4d , vector map : 0x%8X\r\n",0
000054  696d6572
000058  29203a20
00005c  25346420
000060  2c207665
000064  63746f72
000068  206d6170
00006c  203a2030
000070  78253858
000074  0d0a00  
000077  00                DCB      0
                  |L20.120|
                          DCD      0x400049c0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;494    
;;;495    int main()
000000  f7fffffe          BL       SYS_Init
;;;496    {
;;;497        SYS_Init();
;;;498    
;;;499    	GPIO_Init();
000004  f7fffffe          BL       GPIO_Init
;;;500    	UART0_Init();
000008  f7fffffe          BL       UART0_Init
;;;501    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;502        check_reset_source();
000010  f7fffffe          BL       check_reset_source
;;;503    
;;;504        SysTick_enable(1000);
000014  f44f707a          MOV      r0,#0x3e8
000018  f7fffffe          BL       SysTick_enable
;;;505        #if defined (ENABLE_TICK_EVENT)
;;;506        TickSetTickEvent(1000, TickCallback_processA);  // 1000 ms
;;;507        TickSetTickEvent(5000, TickCallback_processB);  // 5000 ms
;;;508        #endif
;;;509    
;;;510        GET_VECMAP();    
00001c  f7fffffe          BL       GET_VECMAP
                  |L21.32|
;;;511    
;;;512        /* Got no where to go, just loop forever */
;;;513        while(1)
;;;514        {
;;;515            loop();
000020  f7fffffe          BL       loop
000024  e7fc              B        |L21.32|
;;;516    
;;;517        }
;;;518    }
;;;519    
                          ENDP


                          AREA ||i.set_systick||, CODE, READONLY, ALIGN=2

                  set_systick PROC
;;;35     
;;;36     void set_systick(unsigned int t)
000000  4901              LDR      r1,|L22.8|
;;;37     {
;;;38     	counter_systick = t;
000002  6008              STR      r0,[r1,#0]  ; counter_systick
;;;39     }
000004  4770              BX       lr
;;;40     
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;97     
;;;98     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L23.8|
;;;99     {
;;;100    	counter_tick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_tick
;;;101    }
000004  4770              BX       lr
;;;102    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      ||.data||

                          AREA ||i.systick_counter||, CODE, READONLY, ALIGN=2

                  systick_counter PROC
;;;40     
;;;41     void systick_counter(void)
000000  4802              LDR      r0,|L24.12|
;;;42     {
;;;43     	counter_systick++;
000002  6801              LDR      r1,[r0,#0]  ; counter_systick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; counter_systick
;;;44     }
000008  4770              BX       lr
;;;45     
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;102    
;;;103    void tick_counter(void)
000000  4805              LDR      r0,|L25.24|
;;;104    {
;;;105    	counter_tick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_tick
000008  6841              LDR      r1,[r0,#4]  ; counter_tick
;;;106        if (get_tick() >= 60000)
00000a  f64e2260          MOV      r2,#0xea60
00000e  4291              CMP      r1,r2
000010  d301              BCC      |L25.22|
;;;107        {
;;;108            set_tick(0);
000012  2100              MOVS     r1,#0
000014  6041              STR      r1,[r0,#4]  ; counter_tick
                  |L25.22|
;;;109        }
;;;110    }
000016  4770              BX       lr
;;;111    
                          ENDP

                  |L25.24|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  6c6f6f70          DCB      0x6c,0x6f,0x6f,0x70
000004  00                DCB      0x00
                  |symbol_number.78|
000005  474554            DCB      0x47,0x45,0x54
000008  5f564543          DCB      0x5f,0x56,0x45,0x43
00000c  4d415000          DCB      0x4d,0x41,0x50,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  counter_systick
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  addr_vector_map
                          DCD      0x00000000
                  LOG1
                          DCD      0x00000000
                  flag_PROJ_CTL
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_6b33c82f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____REVSH|
#line 402
|__asm___6_main_c_6b33c82f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____RRX|
#line 587
|__asm___6_main_c_6b33c82f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
